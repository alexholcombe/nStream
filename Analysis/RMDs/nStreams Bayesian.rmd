---
title: "nStreams Analysis"
author: "Charlie Ludowici"
date: "5/18/2017"
output: html_document
bibliography: Bibtex/nStreams Bayesian.bib
csl: Bibtex/apa.csl
---

```{r echo = FALSE, message=FALSE}
library(ggplot2)
library(reshape2)
library(papaja)
library(magrittr)
library(dplyr)
library(BayesFactor)

theme_set(theme_apa(base_size = 15) ) 

knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE
  )

savePlots <- F


horizErrorBars <- function(data, var.name){
  SPEs <- data[,var.name]
  otherColumn <- colnames(data)[which(colnames(data)!=var.name & colnames(data) != 'participant' & colnames(data) != 'Parameter')]
  y = mean(data[,otherColumn], na.rm=T)
  se = sqrt(var(SPEs)/length(which(!is.na(SPEs))))
  xmin <- mean(SPEs, na.rm=T) - se
  xmax <- mean(SPEs, na.rm=T) + se
  x = mean(SPEs, na.rm=T)
  data.frame(x=x, xmin=xmin, xmax=xmax, y=y)
}

vertErrorBars <- function(data, var.name){
  SPEs <- data[,var.name]
  otherColumn <- colnames(data)[which(colnames(data)!=var.name & colnames(data) != 'participant' & colnames(data) != 'Parameter')]
  x = mean(data[,otherColumn], na.rm=T)
  se = sqrt(var(SPEs)/length(which(!is.na(SPEs))))
  ymin <- mean(SPEs, na.rm=T) - se
  ymax <- mean(SPEs, na.rm=T) + se
  y = mean(SPEs, na.rm=T)
  data.frame(x=x, ymin=ymin, ymax=ymax, y=y)
}


posterior <- function(t, N1, N2=NULL, delta, lo=-Inf, hi = Inf,
                      priorMean=0,priorSD=1) {
        N = ifelse(is.null(N2), N1, N1*N2/(N1+N2))
        df  = ifelse(is.null(N2), N1 - 1, N1 + N2 - 2)
        
        #prior and likelihood
        #prior <- function(delta) dnorm(delta, priorMean, priorSD)*as.integer(delta >= lo)*as.integer(delta <= hi) 
        prior <- function(delta) dcauchy(delta, priorMean, priorSD)*as.integer(delta >= lo)*as.integer(delta <= hi) 
        K=1/integrate(prior,lower=lo,upper=hi)[[1]]
        f=function(delta) K*prior(delta)
        
        #(The as.integer bits above just provide bounds for the prior if you want them)
      
        likelihood <- function(delta) dt(t, df, delta*sqrt(N))
        
        #marginal likelihood
        marginal <- integrate(function(x) f(x)*likelihood(x), lo, hi)[[1]]
        
        #posterior
        post <- function(x) f(x)*likelihood(x) / marginal
        return(post(delta))
}


```

```{r message=FALSE}

null = 0

MMlatency <- read.csv('../../modelOutput/CSV/TGRSVP_Exp2_LatencyNorm.csv')
MMprecision <- read.csv('../../modelOutput/CSV/TGRSVP_Exp2_precisionNorm.csv')
MMefficacy <- read.csv('../../modelOutput/CSV/TGRSVP_Exp2_efficacyNorm.csv')

nStreamLatency <- data.frame(twoStreams = MMlatency$SingleLeft[MMlatency$Group == 1], eightStreams = MMlatency$SingleLeft[MMlatency$Group == 2])

nStreamPrecision <- data.frame(twoStreams = MMprecision$SingleLeft[MMprecision$Group == 1], eightStreams = MMprecision$SingleLeft[MMprecision$Group == 2])

nStreamEfficacy <- data.frame(twoStreams = MMefficacy$SingleLeft[MMefficacy$Group == 1], eightStreams = MMefficacy$SingleLeft[MMefficacy$Group == 2])

frequentistTestLatency = t.test(x = nStreamLatency$eightStreams, y=nStreamLatency$twoStreams, paired = T)
tLatency <- frequentistTestLatency$statistic[[1]]
frequentistTestLatency
```
#2 vs 8 Streams

##Latency Analyses

```{r warning=FALSE}
latencyForPlot <- melt(nStreamLatency, measure.vars = c('twoStreams','eightStreams'),variable.name = 'Condition', value.name = 'Estimate')
latencyForPlot$Participant <- ordered(rep(1:10, times = 2))

t  <- tLatency
N1 <- 10
N2 <- 10

priorMean = null
priorSD = sqrt(.5)

#examples of BF via savage-dickey ratio
#2-sided
BF10 = dcauchy(null,priorMean,priorSD) / posterior(tLatency, N1, delta=null,
                                              priorMean=priorMean,priorSD=priorSD)

#one-sided BF
BFplus = ( 2 * dcauchy(null,priorMean,priorSD) ) / posterior(tLatency, N1, delta=null, lo=0,
                                            priorMean=priorMean,priorSD=priorSD)

delta  <- seq(-2, 4, .01)

posteriorAndPriorDF <- data.frame(delta = delta, posterior = posterior(t,N1,delta=delta, priorMean=priorMean,priorSD=priorSD), prior = dcauchy(delta, priorMean,priorSD))

posteriorModeLatency <- optimize(function(delta) posterior(tLatency, N1, delta=delta, priorMean=priorMean, priorSD=priorSD), interval=c(-4,4),maximum = T)[[1]]

#This would only work for normal, we use Cauchy!
#credibleIntervalDensityLower <- mean(posteriorAndPriorDF$posterior)-sd(posteriorAndPriorDF$posterior)*1.96
#credibleIntervalDensityUpper <- mean(posteriorAndPriorDF$posterior)+sd(posteriorAndPriorDF$posterior)*1.96

latencyHorizSE <- horizErrorBars(nStreamLatency, 'twoStreams')
latencyVertSE <- vertErrorBars(nStreamLatency, 'eightStreams')

latencyPlot <- ggplot(latencyForPlot,aes(x=Condition, y=Estimate))+
  geom_violin()+
  geom_line(aes(group=Participant, colour=Participant))+
  geom_point(aes(colour=Participant), size = 3)+
  stat_summary(geom='point', fun.y = mean, position = position_dodge(.9), aes(shape = 'Means'), size = 5)+
  scale_shape_manual(NULL,breaks = 'Means', values = 23)+
  scale_colour_brewer(palette = 'Spectral')+
  labs(x='Condition',y='Estimate (ms)',title='Latency')+
  theme(plot.title = element_text(hjust=.5))


latencyScatter <- ggplot(nStreamLatency, aes(x=twoStreams, y=eightStreams))+
  geom_point(size = 4, colour = '#FCAD68')+
  lims(x=c(20,120), y=c(20,120))+
  labs(title='Latency Estimates (ms)', x = 'Two Streams', y='Eight Streams')+
  geom_errorbarh(data = latencyHorizSE, aes(x=x, xmin=xmin, xmax = xmax, y=y),inherit.aes = F, height=5)+
  geom_errorbar(data=latencyVertSE, aes(x=x, ymin=ymin,ymax=ymax, y=y), inherit.aes = F, width = 5)+
  stat_summary(geom = 'errorbar', fun.data = mean_se)+
  theme(plot.title = element_text(size=15, hjust=.5))+
  annotate('text', x=100, y=45, label = paste0('BF10 = ', round(BF10,2)))+
  annotate('text', x = 100, y=37, label = paste0('Effect size = ', round(posteriorModeLatency,2)))+
  geom_abline(intercept = 0, slope = 1,linetype='dashed')

show(latencyScatter)



latencyBayesPlot <- ggplot(posteriorAndPriorDF, aes(x=delta))+
  geom_line(aes(y=posterior, linetype = 'Posterior'))+
  geom_line(aes(y=prior, linetype = 'Prior'))+
  scale_linetype_manual(values = c('solid','dashed'),  guide = 'legend', name = NULL)+
  labs(x = expression(delta), y='Density', title = 'Latency Effect Size')
```

BF~10~ is `r round(BF10, 2)`. There is strong evidence for a difference in mean latency between the two- and eight-streams conditions. Mean latency for the two-streams condition (M = `r nStreamLatency %>% pull(twoStreams) %>% mean %>% round(2)`, SD = `r nStreamLatency %>% pull(twoStreams) %>% sd %>% round(2)`) is less than the mean latency for the eight-streams condition (M = `r nStreamLatency %>% pull(eightStreams) %>% mean %>% round(2)`, SD = `r nStreamLatency %>% pull(eightStreams) %>% sd %>% round(2)`).


The nonguessing distribution is delayed in the eight-streams relative to the two-streams condition. There appears to be some cost for increasing the number of streams. Two possible reasons for this are: an attentional cost for distributing attention over more visual space, or a cost of interference due to the increased number of items. These possibilities are theories used in the visual search literature to explain set-size effects [i.e. @palmer_set-size_1994]. This literature distinguished between perceptual effects and those that were due to attention. These theories were tested by holding the number of items constant - thus controling any perceptual effects - but cueing a number of positions as potential target locations. Support for an attentional effect is manifest whenever the effect of set size is similar to that of the pre-cueing manipulation. 

##Precision Analysis

```{r warning=FALSE}
precisionForPlot <- melt(nStreamPrecision, measure.vars = c('twoStreams','eightStreams'),variable.name = 'Condition', value.name = 'Estimate')
precisionForPlot$Participant <- ordered(rep(1:10, times = 2))


frequentistTestPrecision <- t.test(x = nStreamPrecision$eightStreams, y = nStreamPrecision$twoStreams, paired = T)
tPrecision <- frequentistTestPrecision$statistic[[1]]

t  <- tPrecision
N1 <- 10
N2 <- 10

priorMean =0
priorSD = sqrt(.5)

#examples of BF via savage-dickey ratio
#2-sided
BF10 = dcauchy(0,priorMean,priorSD) / posterior(tPrecision, N1, delta=0,
                                              priorMean=priorMean,priorSD=priorSD)

#one-sided BF
BFplus = ( 2 * dcauchy(0,priorMean,priorSD) ) / posterior(tPrecision, N1, delta=0, lo=0,
                                            priorMean=priorMean,priorSD=priorSD)

delta  <- seq(-4, 2, .01)

posteriorModePrecision <- optimize(function(delta) posterior(tPrecision, N1, delta=delta,priorMean=priorMean,priorSD=priorSD), interval=c(-4,4),maximum = T)[[1]]

posteriorAndPriorDF <- data.frame(delta = delta, posterior = posterior(t,N1,delta=delta,
                                                                       priorMean=priorMean,priorSD=priorSD), prior = dcauchy(delta, priorMean,priorSD))

posteriorModePrecision <- optimize(function(delta) posterior(tPrecision, N1, delta=delta, priorMean=priorMean, priorSD=priorSD), interval=c(-4,4),maximum = T)[[1]]


precisionPlot <- ggplot(precisionForPlot,aes(x=Condition, y=Estimate))+
  geom_violin()+
  geom_line(aes(group=Participant, colour=Participant))+
  geom_point(aes(colour=Participant),alpha=.8, size = 3)+
  stat_summary(geom='point', fun.y = mean, position = position_dodge(.9), aes(shape = 'Means'), size = 5)+
  stat_summary(geom='errorbar', fun.data = mean_se, position = position_dodge(.9), width = .1)+
  scale_shape_manual(NULL,breaks = 'Means', values = 23)+
  scale_colour_brewer(palette = 'Spectral')+
  labs(x='Condition',y='Estimate (ms)',title='Precision')+
  theme(plot.title = element_text(hjust=.5))

show(precisionPlot)

precisionHorizSE <- horizErrorBars(nStreamPrecision, 'twoStreams')
precisionVertSE <- vertErrorBars(nStreamPrecision, 'eightStreams')

precisionScatter <- ggplot(nStreamPrecision, aes(x=twoStreams, y=eightStreams, colour=ordered(1:10)))+
  geom_point(size = 4, colour = '#FCAD68')+
  geom_errorbarh(data = precisionHorizSE, aes(x=x, xmin=xmin, xmax = xmax, y=y),inherit.aes = F, height=3)+
  geom_errorbar(data=precisionVertSE, aes(x=x, ymin=ymin,ymax=ymax, y=y), inherit.aes = F, width = 3)+
  lims(x=c(40,100), y=c(40,100))+
  labs(title='Precision Estimates (ms)')+
  scale_shape_manual(breaks = 'Means', values = 3)+
  theme(plot.title = element_text(size=15, hjust=.5))+
  annotate('text', x=90, y=70, label = paste0('BF10 = ', round(BF10,2)))+
  annotate('text', x = 90, y=66, label = paste0('Effect size = ', round(posteriorModePrecision,2)))+
  geom_abline(intercept = 0, slope = 1,linetype='dashed')

show(precisionScatter)

precisionBayesPlot <- ggplot(posteriorAndPriorDF, aes(x=delta))+
  geom_line(aes(y=posterior, linetype = 'Posterior'))+
  geom_line(aes(y=prior, linetype = 'Prior'))+
  scale_linetype_manual(values = c('solid','dashed'),  guide = 'legend', name = NULL)+
  labs(x = expression(delta), y='Density', title = 'Precision Effect Size')


```

Strangely, the precision of the nonguessing distribution decreases as the number of streams increases. The two-streams condition (M = `r nStreamPrecision %>% pull(twoStreams) %>% mean %>% round(2)`, SD = `r nStreamPrecision %>% pull(twoStreams) %>% sd %>% round(2)`) has more variance in the nonguessing distributions than the eight-streams conditions (M = `r nStreamPrecision %>% pull(eightStreams) %>% mean %>% round(2)`, SD = `r nStreamPrecision %>% pull(eightStreams) %>% sd %>% round(2)`; BF~10~ = `r round(BF10,2)`). In a buffering account this could be because as the number of simultaneous items increases there is less capacity to store non-simultaneous items. In an attention shift account this is harder to account for. One possible reason could be that an inability to spread attention over eight streams causes participants to rely on only exogenous attention - rather than an endo-exo mix - and the precision we're seeing here reflects the variability in arrival times for exogenous attention (check the ERP and behavioural literature for exogenous attention estimates). Again, a pre-cuing manipulation is a method for testing this hypothesis.

##Efficacy Analysis

```{r warning=FALSE}
frequentistTestEfficacy <- t.test(x = nStreamEfficacy$eightStreams, y = nStreamEfficacy$twoStreams, paired = T)
tEfficacy <- frequentistTestEfficacy$statistic[[1]]

efficacyForPlot <- melt(nStreamEfficacy, measure.vars = c('twoStreams','eightStreams'), variable.name = 'Condition',value.name = 'Estimate')
efficacyForPlot$Participant <- ordered(rep(1:10, times = 2))

t  <- tEfficacy
N1 <- 10
N2 <- 10

priorMean =0
priorSD = sqrt(.5)

#examples of BF via savage-dickey ratio
#2-sided
BF10 = dcauchy(0,priorMean,priorSD) / posterior(tEfficacy, N1, delta=0,
                                              priorMean=priorMean,priorSD=priorSD)

#one-sided BF
BFplus = ( 2 * dcauchy(0,priorMean,priorSD) ) / posterior(tEfficacy, N1, delta=0, lo=0,
                                            priorMean=priorMean,priorSD=priorSD)

BF10
BFplus

delta  <- seq(-2, 4, .01)

posteriorAndPriorDF <- data.frame(delta = delta, posterior = posterior(t,N1,delta=delta,
                                                                       priorMean=priorMean,priorSD=priorSD), prior = dcauchy(delta, priorMean,priorSD))

posteriorModeEfficacy <- optimize(function(delta) posterior(tEfficacy, N1, delta=delta,priorMean=priorMean,priorSD=priorSD), interval=c(-4,4),maximum = T)[[1]]


efficacyPlot <- ggplot(efficacyForPlot, aes(x=Condition, y=Estimate))+
  geom_violin()+
  geom_line(aes(group=Participant, colour=Participant))+
  geom_point(aes(colour = Participant), size = 3)+
  labs(x='Condition',y='Estimate',title='Efficacy')+
  theme(plot.title = element_text(hjust=.5))+
  scale_colour_brewer(palette = 'Spectral')

efficacyScatter <- ggplot(nStreamEfficacy, aes(x=twoStreams, y=eightStreams, colour=ordered(1:10)))+
  geom_point(size = 4, colour = '#FCAD68')+
  lims(x=c(0,1), y=c(0,1))+
  labs(title='Efficacy Estimates [1 - P(Guess)]', y = 'Eight Streams', y='Eight Streams')+
  theme(plot.title = element_text(size=15, hjust=.5))+
  annotate('text', x=.8, y=.45, label = paste0('BF10 = ', round(BF10,2)))+
  annotate('text', x = .8, y=.37, label = paste0('Effect size = ', round(posteriorModeEfficacy,2)))+
  geom_abline(intercept = 0, slope = 1,linetype='dashed')

show(efficacyScatter)

efficacyBayesPlot <- ggplot(posteriorAndPriorDF, aes(x=delta))+
  geom_line(aes(y=posterior, linetype = 'Posterior'))+
  geom_line(aes(y=prior, linetype = 'Prior'))+
  scale_linetype_manual(values = c('solid','dashed'),  guide = 'legend', name = NULL)+
  labs(x = expression(delta), y='Density', title = 'Efficacy Effect Size')


```
The Bayesian analysis for the efficacy data shows weak evidence for a lack of an effect (BF~10~ = `r round(BF10,2)`). The mean for the two-streams condition is `r nStreamEfficacy %>% pull(twoStreams) %>% mean %>% round(2)` (SD = `r nStreamEfficacy %>% pull(twoStreams) %>% sd %>% round(2)`). The mean for the eight-streams condition is `r nStreamEfficacy %>% pull(eightStreams) %>% mean %>% round(2)` (SD = `r nStreamEfficacy %>% pull(eightStreams) %>% sd %>% round(2)`).
```{r}

predictions <- data.frame(twoStreams = rnorm(1000, nStreamLatency$twoStreams[7], nStreamPrecision$twoStreams[7]), eightStreams = rnorm(1000, nStreamLatency$eightStreams[7], nStreamPrecision$eightStreams[7]))

predictions <- melt(predictions, measure.vars = c('twoStreams', 'eightStreams'), variable.name = 'Condition', value.name = 'response')

meanLatencyTwo <- mean(nStreamLatency$twoStreams)
meanLatencyEight <- mean(nStreamLatency$eightStreams)

meanPrecisionTwo <- mean(nStreamPrecision$twoStreams)
meanPrecisionEight <- mean(nStreamPrecision$eightStreams)


predictionPlot <- ggplot()+
  stat_function(data=data.frame(x=c(-400:400)/83.33), aes(x, fill = 'Two Streams'), fun = dnorm, args = list(mean = meanLatencyTwo/83.33, sd = meanPrecisionTwo/83.33), geom='area', alpha = .5)+
  stat_function(data=data.frame(x=c(-400:400)/83.33), aes(x, fill = 'Eight Streams'), fun = dnorm, args = list(mean = meanLatencyEight/83.33, sd = meanPrecisionEight/83.33), geom='area', alpha = .6)+
  scale_fill_brewer(palette = 'Set1')+
  scale_x_continuous(breaks = -3:4,limits = c(-3,4))+
  labs(x='SPE', y=NULL, fill = 'Condition', title = 'Estimated non-guessing Distributions')

predictionPlot


if(savePlots){
  ggsave(precisionPlot, file = '../Plots/precisionViolin.png', height=15, width=20,units='cm')
  ggsave(latencyPlot, file = '../Plots/latencyViolin.png', height=15, width=20,units='cm')
  ggsave(efficacyPlot, file = '../Plots/efficacyViolin.png', height=15, width=20,units='cm')
  
  ggsave(precisionScatter, file = '../Plots/precisionScatter.png', height=15, width=20,units='cm')
  ggsave(latencyScatter, file = '../Plots/latencyScatter.png', height=15, width=20,units='cm')
  ggsave(efficacyScatter, file = '../Plots/efficacyScatter.png', height=15, width=20,units='cm')
  
  
  ggsave(efficacyBayesPlot, file = '../Plots/efficacyEffectSize.png', height=15, width=20,units='cm')
  ggsave(latencyBayesPlot, file = '../Plots/latencyEffectSize.png', height=15, width=20,units='cm')
    ggsave(precisionBayesPlot, file = '../Plots/precisionEffectSize.png', height=15, width=20,units='cm')
}
```

#Precue Data
```{r message=FALSE}

null = 0

nParticipants <- 13

MMlatency <- read.csv('../../modelOutput/precueCSV/TGRSVP_Exp2_LatencyNorm.csv')
MMprecision <- read.csv('../../modelOutput/precueCSV/TGRSVP_Exp2_precisionNorm.csv')
MMefficacy <- read.csv('../../modelOutput/precueCSV/TGRSVP_Exp2_efficacyNorm.csv')

preCueLatency <- data.frame(twoStreams = MMlatency$SingleLeft[MMlatency$Group == 1], eightStreams = MMlatency$SingleLeft[MMlatency$Group == 2])

preCuePrecision <- data.frame(twoStreams = MMprecision$SingleLeft[MMprecision$Group == 1], eightStreams = MMprecision$SingleLeft[MMprecision$Group == 2])

preCueEfficacy <- data.frame(twoStreams = MMefficacy$SingleLeft[MMefficacy$Group == 1], eightStreams = MMefficacy$SingleLeft[MMefficacy$Group == 2])

frequentistTestLatency = t.test(x = preCueLatency$eightStreams, y=preCueLatency$twoStreams, paired = T)
tLatency <- frequentistTestLatency$statistic[[1]]
frequentistTestLatency
```

In this experiment, the program presented 8 streams on each trial. Prior to the onset of a trial, participants saw a circular array of hashmarks for 250ms, as in  @goodbourn_pseudoextinction, this was followed by a blank screen for 500ms, a fixation point for 1000ms and then the RSVP streams. The possible position of the cue on a trial was indicated by white rings around either two or eight streams. These mimicked the position of the streams in the first experiment's conditions. This experiment tests whether any differences between the two or eight streams conditions are due to increasing interference that scales with the number of streams - this theory predicts no difference between conditions in this experiment - or due to a cost involved in spreading attention over a larger area of visual space - this theory predicts a replication of the initial experiment's effects. 

##Latency Analyses

```{r warning=FALSE}
latencyForPlot <- melt(preCueLatency, measure.vars = c('twoStreams','eightStreams'),variable.name = 'Condition', value.name = 'Estimate')
latencyForPlot$Participant <- ordered(rep(1:nParticipants, times = 2))

t  <- tLatency
N1 <- nParticipants
N2 <- nParticipants

priorMean = null
priorSD = sqrt(.5)

#examples of BF via savage-dickey ratio
#2-sided
BF10 = dcauchy(null,priorMean,priorSD) / posterior(tLatency, N1, delta=null,
                                              priorMean=priorMean,priorSD=priorSD)

#one-sided BF
BFplus = ( 2 * dcauchy(null,priorMean,priorSD) ) / posterior(tLatency, N1, delta=null, lo=0,
                                            priorMean=priorMean,priorSD=priorSD)

delta  <- seq(-2, 4, .01)

posteriorAndPriorDF <- data.frame(delta = delta, posterior = posterior(t,N1,delta=delta, priorMean=priorMean,priorSD=priorSD), prior = dcauchy(delta, priorMean,priorSD))

posteriorModeLatency <- optimize(function(delta) posterior(tLatency, N1, delta=delta, priorMean=priorMean, priorSD=priorSD), interval=c(-4,4),maximum = T)[[1]]

#This would only work for normal, we use Cauchy!
#credibleIntervalDensityLower <- mean(posteriorAndPriorDF$posterior)-sd(posteriorAndPriorDF$posterior)*1.96
#credibleIntervalDensityUpper <- mean(posteriorAndPriorDF$posterior)+sd(posteriorAndPriorDF$posterior)*1.96


latencyPlot <- ggplot(latencyForPlot,aes(x=Condition, y=Estimate))+
  geom_violin()+
  geom_line(aes(group=Participant, colour=Participant))+
  geom_point(aes(colour=Participant), size = 3)+
  scale_colour_brewer(palette = 'Spectral')+
  labs(x='Condition',y='Estimate (ms)',title='Latency')+
  theme(plot.title = element_text(hjust=.5))


latencyScatter <- ggplot(preCueLatency, aes(x=twoStreams, y=eightStreams))+
  geom_point(size = 4, colour = '#FCAD68')+
  lims(x=c(20,220), y=c(20,220))+
  labs(title='Latency Estimates (ms)', x = 'Two Streams', y='Eight Streams')+
  theme(plot.title = element_text(size=15, hjust=.5))+
  annotate('text', x=100, y=45, label = paste0('BF10 = ', round(BF10,2)))+
  annotate('text', x = 100, y=37, label = paste0('Effect size = ', round(posteriorModeLatency,2)))+
  geom_abline(intercept = 0, slope = 1,linetype='dashed')

show(latencyScatter)



latencyBayesPlot <- ggplot(posteriorAndPriorDF, aes(x=delta))+
  geom_line(aes(y=posterior, linetype = 'Posterior'))+
  geom_line(aes(y=prior, linetype = 'Prior'))+
  scale_linetype_manual(values = c('solid','dashed'),  guide = 'legend', name = NULL)+
  labs(x = expression(delta), y='Density', title = 'Latency Effect Size')
```

The latency for the two-precues condition (M = `r preCueLatency %>% pull(twoStreams) %>% mean %>% round(2)`, SD = `r preCueLatency %>% pull(twoStreams) %>% sd %>% round(2)`) is less than that of the eight-precues condition (M = `r preCueLatency %>% pull(eightStreams) %>% mean %>% round(2)`, SD = `r preCueLatency %>% pull(eightStreams) %>% sd %>% round(2)`; BF~10~ = `r round(BF10,2)`). 

#Precision Analysis

```{r warning=FALSE}
precisionForPlot <- melt(preCuePrecision, measure.vars = c('twoStreams','eightStreams'),variable.name = 'Condition', value.name = 'Estimate')
precisionForPlot$Participant <- ordered(rep(1:nParticipants, times = 2))


frequentistTestPrecision <- t.test(x = preCuePrecision$eightStreams, y = preCuePrecision$twoStreams, paired = T)
tPrecision <- frequentistTestPrecision$statistic[[1]]

t  <- tPrecision
N1 <- nParticipants
N2 <- nParticipants

priorMean =0
priorSD = sqrt(.5)

#examples of BF via savage-dickey ratio
#2-sided
BF10 = dcauchy(0,priorMean,priorSD) / posterior(tPrecision, N1, delta=0,
                                              priorMean=priorMean,priorSD=priorSD)

#one-sided BF
BFplus = ( 2 * dcauchy(0,priorMean,priorSD) ) / posterior(tPrecision, N1, delta=0, lo=0,
                                            priorMean=priorMean,priorSD=priorSD)

BF10
BFplus

delta  <- seq(-4, 2, .01)

posteriorModePrecision <- optimize(function(delta) posterior(tPrecision, N1, delta=delta,priorMean=priorMean,priorSD=priorSD), interval=c(-4,4),maximum = T)[[1]]

posteriorAndPriorDF <- data.frame(delta = delta, posterior = posterior(t,N1,delta=delta,
                                                                       priorMean=priorMean,priorSD=priorSD), prior = dcauchy(delta, priorMean,priorSD))

posteriorModePrecision <- optimize(function(delta) posterior(tPrecision, N1, delta=delta, priorMean=priorMean, priorSD=priorSD), interval=c(-4,4),maximum = T)[[1]]


precisionPlot <- ggplot(precisionForPlot,aes(x=Condition, y=Estimate))+
  geom_violin()+
  geom_line(aes(group=Participant, colour=Participant))+
  geom_point(aes(colour=Participant),alpha=.8, size = 3)+
  scale_colour_brewer(palette = 'Spectral')+
  labs(x='Condition',y='Estimate (ms)',title='Precision')+
  theme(plot.title = element_text(hjust=.5))



precisionScatter <- ggplot(preCuePrecision, aes(x=twoStreams, y=eightStreams, colour=ordered(1:nParticipants)))+
  geom_point(size = 4, colour = '#FCAD68')+
  lims(x=c(40,200), y=c(40,200))+
  labs(title='Precision Estimates (ms)')+
  theme(plot.title = element_text(size=15, hjust=.5))+
  annotate('text', x=90, y=70, label = paste0('BF10 = ', round(BF10,2)))+
  annotate('text', x = 90, y=66, label = paste0('Effect size = ', round(posteriorModePrecision,2)))+
  geom_abline(intercept = 0, slope = 1,linetype='dashed')

show(precisionScatter)

precisionBayesPlot <- ggplot(posteriorAndPriorDF, aes(x=delta))+
  geom_line(aes(y=posterior, linetype = 'Posterior'))+
  geom_line(aes(y=prior, linetype = 'Prior'))+
  scale_linetype_manual(values = c('solid','dashed'),  guide = 'legend', name = NULL)+
  labs(x = expression(delta), y='Density', title = 'Precision Effect Size')


```

There is weak evidence for no difference between the two conditions, BF~10~ = `r round(BF10,2)`. The two-precues condition has a mean of `r preCuePrecision %>% pull(twoStreams) %>% mean %>% round(2)` (SD = `r preCuePrecision %>% pull(twoStreams) %>% sd %>% round(2)`). The eight-precues condition has a mean of `r preCuePrecision %>% pull(eightStreams) %>% mean %>% round(2)` (SD = `r preCuePrecision %>% pull(eightStreams) %>% sd %>% round(2)`).

#Efficacy Analysis

```{r warning=FALSE}
frequentistTestEfficacy <- t.test(x = preCueEfficacy$eightStreams, y = preCueEfficacy$twoStreams, paired = T)
tEfficacy <- frequentistTestEfficacy$statistic[[1]]

efficacyForPlot <- melt(preCueEfficacy, measure.vars = c('twoStreams','eightStreams'), variable.name = 'Condition',value.name = 'Estimate')
efficacyForPlot$Participant <- ordered(rep(1:nParticipants, times = 2))

t  <- tEfficacy
N1 <- nParticipants
N2 <- nParticipants

priorMean =0
priorSD = sqrt(.5)

#examples of BF via savage-dickey ratio
#2-sided
BF10 = dcauchy(0,priorMean,priorSD) / posterior(tEfficacy, N1, delta=0,
                                              priorMean=priorMean,priorSD=priorSD)

#one-sided BF
BFplus = ( 2 * dcauchy(0,priorMean,priorSD) ) / posterior(tEfficacy, N1, delta=0, lo=0,
                                            priorMean=priorMean,priorSD=priorSD)

BF10
BFplus

delta  <- seq(-2, 4, .01)

posteriorAndPriorDF <- data.frame(delta = delta, posterior = posterior(t,N1,delta=delta,
                                                                       priorMean=priorMean,priorSD=priorSD), prior = dcauchy(delta, priorMean,priorSD))

posteriorModeEfficacy <- optimize(function(delta) posterior(tEfficacy, N1, delta=delta,priorMean=priorMean,priorSD=priorSD), interval=c(-4,4),maximum = T)[[1]]


efficacyPlot <- ggplot(efficacyForPlot, aes(x=Condition, y=Estimate))+
  geom_violin()+
  geom_line(aes(group=Participant, colour=Participant))+
  geom_point(aes(colour = Participant), size = 3)+
  labs(x='Condition',y='Estimate',title='Efficacy')+
  theme(plot.title = element_text(hjust=.5))+
  scale_colour_brewer(palette = 'Spectral')


efficacyScatter <- ggplot(preCueEfficacy, aes(x=twoStreams, y=eightStreams))+
  geom_point(size = 4, colour = '#FCAD68')+
  lims(x=c(0,1), y=c(0,1))+
  labs(title='Efficacy Estimates [1 - P(Guess)]', y = 'Eight Streams', y='Eight Streams')+
  theme(plot.title = element_text(size=15, hjust=.5))+
  annotate('text', x=.8, y=.45, label = paste0('BF10 = ', round(BF10,2)))+
  annotate('text', x = .8, y=.37, label = paste0('Effect size = ', round(posteriorModeEfficacy,2)))+
  geom_abline(intercept = 0, slope = 1,linetype='dashed')

show(efficacyScatter)

efficacyBayesPlot <- ggplot(posteriorAndPriorDF, aes(x=delta))+
  geom_line(aes(y=posterior, linetype = 'Posterior'))+
  geom_line(aes(y=prior, linetype = 'Prior'))+
  scale_linetype_manual(values = c('solid','dashed'),  guide = 'legend', name = NULL)+
  labs(x = expression(delta), y='Density', title = 'Efficacy Effect Size')


```

There is weak evidence for no difference between the two conditions, BF~10~ = `r round(BF10,2)`. The two-precues condition has a mean of `r preCueEfficacy %>% pull(twoStreams) %>% mean %>% round(2)` (SD = `r preCueEfficacy %>% pull(twoStreams) %>% sd %>% round(2)`). The eight-precues condition has a mean of `r preCueEfficacy %>% pull(eightStreams) %>% mean %>% round(2)` (SD = `r preCueEfficacy %>% pull(eightStreams) %>% sd %>% round(2)`).

```{r}

preCueEfficacy$Parameter <- as.character('Efficacy')
preCueLatency$Parameter <- as.character('Latency')
preCuePrecision$Parameter <- as.character('Precision')

allParams <- rbind(preCueEfficacy,preCueLatency,preCuePrecision)

allParams <- melt(allParams, measure.vars = c('twoStreams','eightStreams'), variable.name = 'Condition',value.name = 'Estimate')

paramBar <- ggplot(allParams[!allParams$Parameter=='Efficacy',], aes(x=Parameter,y=Estimate, fill = Condition))+
  stat_summary(geom='bar', fun.y = mean, position = position_dodge(.9))+
  stat_summary(geom='errorbar', fun.data=mean_se, position = position_dodge(.9), width = .3)+
  scale_fill_brewer(palette = 'Spectral')

paramBar

predictions <- data.frame(twoStreams = rnorm(1000, preCueLatency$twoStreams[7], preCuePrecision$twoStreams[7]), eightStreams = rnorm(1000, preCueLatency$eightStreams[7], preCuePrecision$eightStreams[7]))

predictions <- melt(predictions, measure.vars = c('twoStreams', 'eightStreams'), variable.name = 'Condition', value.name = 'response')

meanLatencyTwo <- mean(preCueLatency$twoStreams)
meanLatencyEight <- mean(preCueLatency$eightStreams)

meanPrecisionTwo <- mean(preCuePrecision$twoStreams)
meanPrecisionEight <- mean(preCuePrecision$eightStreams)


predictionPlot <- ggplot()+
  stat_function(data=data.frame(x=c(-400:400)/83.33), aes(x, fill = 'Two Streams'), fun = dnorm, args = list(mean = meanLatencyTwo/83.33, sd = meanPrecisionTwo/83.33), geom='area', alpha = .5)+
  stat_function(data=data.frame(x=c(-400:400)/83.33), aes(x, fill = 'Eight Streams'), fun = dnorm, args = list(mean = meanLatencyEight/83.33, sd = meanPrecisionEight/83.33), geom='area', alpha = .6)+
  scale_fill_brewer(palette = 'Set1')+
  scale_x_continuous(breaks = -3:4,limits = c(-3,4))+
  labs(x='SPE', y=NULL, fill = 'Condition')

predictionPlot


if(savePlots){
  ggsave(precisionPlot, file = '../Plots/precisionViolin.png', height=15, width=20,units='cm')
  ggsave(latencyPlot, file = '../Plots/latencyViolin.png', height=15, width=20,units='cm')
  ggsave(efficacyPlot, file = '../Plots/efficacyViolin.png', height=15, width=20,units='cm')
  
  ggsave(precisionScatter, file = '../Plots/precisionScatter.png', height=15, width=20,units='cm')
  ggsave(latencyScatter, file = '../Plots/latencyScatter.png', height=15, width=20,units='cm')
  ggsave(efficacyScatter, file = '../Plots/efficacyScatter.png', height=15, width=20,units='cm')
  
  
  ggsave(efficacyBayesPlot, file = '../Plots/efficacyEffectSize.png', height=15, width=20,units='cm')
  ggsave(latencyBayesPlot, file = '../Plots/latencyEffectSize.png', height=15, width=20,units='cm')
    ggsave(precisionBayesPlot, file = '../Plots/precisionEffectSize.png', height=15, width=20,units='cm')
}
```

##Summary
We replicated the effect of the number of streams on latency but not precision in this experiment. The delayed latency in the eight-precue condition relative to the two-precue condition cannot be because of crowding-like interference due to the number of streams displayed because the number of streams is constant across conditions. What changes is the number of potential cue positions, and thus the number of streams that must be monitored. Our latency results are then consistent with the idea that monitoring several locations for a target is taxing for the visual system and either the detection of the target or the selection of items contingent on the target lag because of this. 

```{r}
twovEightStreamsCrossExp <- ttestBF(preCueLatency$twoStreams, nStreamLatency$eightStreams, paired = F)
twovEightStreamsCrossExp
```

@palmer_set-size_1994 argues that pre-cueing components of a visual array while holding the stimuli constant gives a measure of attentional contributions to an effect. The results of our pre-cue experiment thus suggest that the latency effect is due to an attentional effect. One candidate is a cost associated with monitoring multiple stream locations. In @hogendoorn_timing_2010 (and Huang & Pashler, which I haven't yet read), the authors distinguish between attention's ability to optimise - i.e. speed up - processing at attended sites and its ability to select features and bind them into an object. Precuing a stimulus manipulates monitoring - processing of the cue should be sped up. However a bayesian t-test of the difference in latencies between experiments in the two streams conditions yields only weak evidence, and this evidence is in favour of the null (`r twovEightStreamsCrossExp %>% .@bayesFactor %>% .$bf %>% exp %>% round(2)`).
